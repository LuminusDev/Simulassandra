\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[tikz]{bclogo}
\usepackage{geometry}
\usepackage{array}
\usepackage{pgfgantt}
\usepackage{url}
\bibliographystyle{alpha}
\usepackage[counterclockwise]{rotating}
\geometry{hmargin=2.5cm,vmargin=1.5cm}

\setlength{\parskip}{1ex plus 2ex minus 1ex}
\newcolumntype{M}[1]{
    >{\raggedright}m{#1}
}

\newcommand{\besoin}[2] {
  (\textit{Priorité} : #1, \textit{criticité} : #2)
}

\title{
 \begin{minipage}\linewidth
        \centering
        Simulation d'algorithmes d'équilibrage de charge dans un environnement distribué 
        \vskip3pt
        \large Identifications des besoins
    \end{minipage}
 }
 
\bibliographystyle{alpha}
\author{Kevin Barreau \and Guillaume Marques \and Corentin Salingue}

\begin{document}

\maketitle

\abstract
Ce document dégage une première identification des besoins.



\newpage


\renewcommand{\contentsname}{Sommaire} 
\tableofcontents



\newpage

\section{Définition du projet}

\subsection{Contexte}

\paragraph{} L'expansion, au cours des deux dernières décennies, des réseaux et notamment d'Internet a engendré une importante création de données, massives par leur nombre et leur taille.
Stocker ces informations sur un seul point de stockage (ordinateur par exemple) n'est bien sûr plus envisageable, que ce soit pour des raisons techniques ou pour des raisons de sûreté (pannes potentielles par exemple).
Pour cela des systèmes de stockages dits distribués sont utilisés en pratique afin des les répartir sur différentes unités de stockages.

\paragraph{Définition} Un environnement distribué est constitué de plusieurs machines (ordinateurs), appelées \textit{noeuds}, sur lesquelles sont stockées des données.

\paragraph{Définition} Une donnée est une suite binaire de $0$ et de $1$ dont le contenu n'est pas important pour l'application.

\paragraph{} Le client souhaite répartir toutes ces données de manière équitable entre les noeuds. De plus, ces données doivent être accessibles afin de pouvoir les requêter et récupérer de l'information.

\paragraph{Définition} Une requête est un message envoyé à une machine (ou plusieurs machines) afin de récupérer ou de modifier de l'information sur des données.
Nous noterons que la nature de l'information est inutile pour le bon fonctionnement de l'application.

\paragraph{} Pour répartir toutes ces données, notre client a développé de nouveaux algorithmes d'équilibrage de charge et de réplication qu'il souhaite tester dans un environnement distribué.

\paragraph{Définition} Une \textit{charge} est associée à un noeud et désigne le nombre de requêtes que le noeud doit traiter. 

\paragraph{Définition} La réplication d'une donnée consiste à faire des copies de cette donnée sur d'autres noeuds.

\subsection{Finalité}

\paragraph{} Nous devons développer une solution logicielle permettant de tester ces nouveaux algorithmes d'équilibrage de charge et de réplication dans un environnement distribué.

\paragraph{Définition} Un réseau est un ensemble de noeuds qui sont reliés entre eux (en général par Internet) et qui communiquent ensemble afin de traiter toutes les requêtes reçues.

\paragraph{Définition} La topologie d'un réseau représente l'architecture physique ou logicielle des liens entre les noeuds. Elle comporte aussi des informations sur la
 hiérarchie des noeuds, le placement spatial et les divers équipements reliant les noeuds.

\paragraph{Définition} L'état d'un réseau est l'ensemble des informations caractérisant un réseau (topologie par exemple) ainsi que des informations sur les noeuds (comme leur charge actuelle).

\paragraph{Définition} Un jeu de données est un ensemble de données dont on connait la position sur les noeuds (la donnée numéro X est sur le noeud numéro Y), éventuellement, leur contenu et qu'on est capable d'exporter et de reproduire. L'export pourra se faire sous la forme d'un jeu de requêtes pour placer les données choisies.

\paragraph{Définition} Un jeu de requêtes est un ensemble de requêtes qu'on est capable d'exporter sous forme d'un programme ou d'un fichier qui sera exécuté par la solution et qui peut être reproduit.

\paragraph{}Cette solution doit permettre le paramétrage d'un réseau, c'est-à-dire le nombre de noeuds souhaité et la topologie du réseau.
Le client pourra simuler différents jeux de données et jeux de requêtes sur ce réseau. Cela permettra de comparer l'efficacité de ces algorithmes avec le même environnement (même jeux de données et de requêtes).
Il pourra tester ses algorithmes implémentés.
Enfin, il pourra visualiser la topologie et l'état du réseau \textit{à tout moment}.




%\newpage
\section{Hiérarchisation des besoins}

\paragraph{} Nous avons dégagé des précédentes réunions, une liste de besoins fonctionnels et non-fonctionnels. 
Pour mieux les comparer, nous les avons hiérarchisés en fonction de leur priorité et de leur criticité.


\subsection{Priorité}

\paragraph{} La priorité est un indicateur de l'ordre dans lequel nous devrons implémenter les besoins afin de satisfaire au mieux les exigences du client.

\paragraph{}
\begin{tabular}{| l | M{3cm} | M{9cm} |}
    \hline
    Valeur & Signification & Description \tabularnewline
    \hline
    1 & Priorité haute & A implémenter dans les premiers temps \tabularnewline
    \hline
    2 & Priorité moyenne & A implémenter  \tabularnewline
    \hline
    3 & Priorité faible & A implémenter (en fonction du temps restant)  \tabularnewline
    \hline
 \end{tabular}
 

\subsection{Criticité}

\paragraph{} Le niveau de criticité d'un besoin est un indicateur de l'impact qu'aura la non-implémentation de ce besoin sur le bon fonctionnement de l'application.

\paragraph{}
\begin{tabular}{| l | M{3cm} | M{9cm} |}
    \hline
    Valeur & Signification & Description \tabularnewline
    \hline
    1 & Criticité extrême & L'application ne fonctionnera pas  \tabularnewline
    \hline
    2 & Criticité haute & Certaines fonctionnalités de l'application ne fonctionneront pas  \tabularnewline
    \hline
    3 & Criticité moyenne & Certaines fonctionnalités seront perturbées  \tabularnewline
    \hline
    4 & Criticité faible & L'application fonctionnera correctement  \tabularnewline
    \hline
 \end{tabular}



\newpage

\section{Besoins fonctionnels}


\subsection{Environnement distribué}

\paragraph{} Nous évoluerons dans un environnement distribué \besoin{1}{1} constitué de $n$ noeuds de stockage dans lequel on souhaite stocker $m$ objets.
En effet, l'application doit permettre de tester des algorithmes d'équilibrage de charges et de gestion de copies qui ne peuvent fonctionner uniquement dans un environnement distribué.


\subsection{Gestion d'un réseau}

\paragraph{} Comme défini précédemment, un réseau est un ensemble de noeuds qui sont reliés entre eux (en général par Internet) et qui communiquent ensemble afin de traiter toutes les requêtes reçues.


\subsubsection{Gestion des noeuds}

\paragraph{} Un noeud est une machine (ordinateur généralement) pouvant stocker des données et traiter des requêtes. Un noeud possède des données locales propres au fonctionnement du noeud (comme la charge par exemple).

\paragraph{Création d'un noeud} La création d'un noeud \besoin{1}{1} se fait au moment où le réseau n'existe pas encore. 
Le projet ne prend en compte ni la création dynamique de noeud (création et ajout d'un noeud après que le réseau soit créé), ni la suppression de noeud. 
Il est possible de séparer ce besoin en plusieurs sous-besoins :
 \begin{itemize}
 	\item Créer un noeud dans l'environnement de simulation
 	\item Initialiser les données locales d'un noeud
 \end{itemize}
 
\paragraph{Données locales d'un noeud} Chaque noeud doit contenir les données locales \besoin{1}{1} suivantes :
\begin{itemize}
 \item 1 vecteur correspondant à la charge de tous les noeuds
 \item 2 vecteurs  correspondant à la popularité de chaque objet
 \item 1 file d'attente de message
 \item la requête en cours de traitement
\end{itemize}

\paragraph{Mise à jour des données} Afin de connaître l'état du réseau de manière précise, les données locales doivent être mise à jour à chaque action \besoin{1}{1}.
Une mise à jour à donc lieu à l'arrivée d'un message dans la file d'attente

\paragraph{Récupération de l'état du réseau} L'application doit permettre la description de l'état du réseau \besoin{1}{1}.
On souhaite connaître : 
\begin{itemize}
 \item la charge des noeuds
 \item le nombre de requêtes en attente
 \item la popularité des objets
\end{itemize}
Une partie de ces données font ensuite l'objet d'un affichage. \footnote{Objet de la partie 3.5 Visualisation des données}

 
\subsubsection{Gestion des objets}

\paragraph{} Un objet est...

\paragraph{} Une fois l'ensemble des noeuds crée, on doit pouvoir affecter à chaque noeud des objets.

\paragraph{Création d'un objet} A détailler

\paragraph{Suppression d'un objet} A détailler


\subsubsection{Popularité d'un objet}

\paragraph{} Les algorithmes du client nécessitent de connaître la popularité d'un objet dans le réseau \besoin{1}{1}.
La popularité d'un objet est fonction du nombre de requêtes sur cet objet. Plus ce nombre de requêtes est grand, plus l'objet est populaire.

\paragraph{Algorithme} La calcul de la popularité nécessite l'implémentation de l'algorithme d'approximation Space-Saving Algorithm \cite{SpaceSaving}.


\subsubsection{Topologie du réseau}

\paragraph{} Un noeud maître est un noeud connu de tous les autres noeuds dans le réseau. 
Un noeud communique à un intervalle de temps régulier avec les autres noeuds du réseau. 
Tous les noeuds du réseau possèdent des informations sur les autres noeuds du réseau.

\paragraph{Communication} Les données locales d'un noeud doivent être communiqué à un noeud maître \besoin{1}{1}.
Le noeud maître peut centraliser toutes les données locales de chaque noeud et ainsi connaître l'état du réseau.

\paragraph{Paramétrage} Lorsqu'il n'y aucune requête à traiter sur le réseau, l'état du réseau est stable.
Plus précisément, les données locales de chaque noeud ne changent pas.
Malheureusement, ils continuent de communiquer entre eux.
Pour éviter ces échanges de messages inutiles, on souhaite pouvoir paramétrer l'intervalle de temps de communication \besoin{2}{4}.

\paragraph{Stockage} Stocker les informations des autres noeuds \besoin{1}{2}  (???)


\subsubsection{Sauvegarde d'un réseau}

\paragraph{}  Objet de la prochaine réunion


\subsubsection{Importation d'un réseau}

\paragraph{} Objet de la prochaine réunion


\subsection{Algorithmes}

\subsubsection{Algorithmes à implémenter}

\paragraph{Définitions} La charge minimum est ...

\paragraph{} La charge moyenne est ...

\paragraph{} Les algorithmes d'équilibrage de charge à implémenter sont (extrait du modèle du client) :

\begin{itemize}
 \item \textbf{SLVO} \besoin{1}{1} 
 \begin{itemize}
  \item Déterminer la charge minimum courante.
  \item Si la charge du noeud est inférieure ou égale à la charge minimum, il s'affecte toutes les requêtes en attente et en avertit les autres noeuds. \vspace{0.2cm}
 \end{itemize}
 \item \textbf{AverageDegree} \besoin{1}{1} 
 \begin{itemize}
  \item Déterminer la charge moyenne courante
  \item Si la charge du noeud est inférieure ou égale à la charge moyenne, il s'affecte toutes les requêtes en attente et en avertit les autres noeuds.
 \end{itemize}
\end{itemize}

\paragraph{Gestion des copies} Entité à part entière ? (prochaine réunion)


\subsubsection{Conformité des implémentations}

\paragraph{} La conformité des algorithmes implémentés est assurée par des jeux de tests suivant la démarche :

\begin{itemize}
	\item Créer un jeu de test à la main, comprenant les paramètres de création et l'ensemble des requêtes à traiter
	\item Faire fonctionner l'algorithme à la main
	\item Stocker l'état final du fonctionnement de l'algorithme
	\item Faire valider le processus à la main par le client
	\item Lancer la simulation de l'algorithme avec le jeu de test créé à la main
	\item Vérifier les résultats constatés avec les résultats attendus
\end{itemize}
	
\paragraph{} Si il y a une différence entre le résultat de l'éxécution de l'algorithme à la main et le résultat de l'éxécution par simulation, une vérification par le client peut être envisagée dans le cas de résultats \textit{presque} similaires. 
La notion de similitude est laissée à l'appréciation de l'équipe en charge du projet, lors de la vérification.


\subsubsection{Autres algorithmes}

\paragraph{} L'application doit permettre aussi avoir la possibilité de tester d'autres algorithmes. 
Notre solution doit donc proposer un système permettant d'implémenter ces algorithmes et de les tester. \besoin{3}{3} 


\subsection{Simulation de requêtes}

\paragraph{} Une requête est un message envoyé à une machine (ou plusieurs machines) afin de récupérer ou de modifier de l'information sur des données.


\subsubsection{Création d'une requête}

\paragraph{} Une fois le réseau crée, l'utilisateur peut en


\subsubsection{Sauvegarde d'un jeu de requête}

\paragraph{} Objet de la prochaine réunion (SENS?)


\subsubsection{Importation d'un jeu de requête}

\paragraph{} Objet de la prochaine réunion (SENS?)


\subsection{Visualisation des données}

\begin{itemize}
 \item Temps de réponse moyen sur les requêtes passées.
 \item Charge d'un noeud
 \item Popularité des objets
\end{itemize}

\textbf{Note } Bien définir ces items. \newline



\newpage

\section{Besoins non fonctionnels}

\subsection{Cassandra}

\paragraph{} Cassandra est une base de données distribuée.
Nous créons notre environnement de simulation à partir de la dernière version stable, \texttt{Cassandra 2.1.2}.

\paragraph{} Le choix de cette solution nous a été fortement recommandé par le client.
En effet, celui-ci dispose de connaissances sur cette application et pourra donc plus facilement intervenir s'il souhaite faire évoluer le projet en implémentant par exemple de nouveaux algorithmes.


\subsection{Gestion d'un réseau}

\subsubsection{Communication entre noeuds}

\paragraph{}Pour connaître l'état du réseau, il faut regrouper les données locales des noeuds.
Nous cherchons donc a récupérer ces données en un temps raisonnable ($O(log(n))$ pour $n$ noeuds).

\paragraph{}Pour cela, nous nous appuierons sur le protocole \texttt{Gossip} \cite{gossip}.
Périodiquement, chaque noeud choisi $n$ noeuds aléatoirement dont un noeud \textit{seed}, noeud en mesure d'avoir une connaissance globale du système \cite{seed}, et il communique à ces noeuds ses statistiques (valeur de sa charge, objets les plus populaires...).

\paragraph{}Ainsi, la connaissance globale du système se fait en $O(log(n))$.


\subsubsection{Taille des données}

\paragraph{}Objet prochaine réunion


\subsection{Visualisation des données}

\paragraph{} Une vue correspond à une fenêtre de l'application, c'est à dire ce que voit l'utilisateur.


\subsubsection{Etat du réseau}

\paragraph{} La vue permet de montrer l'état du réseau.

\paragraph{} Le réseau est représenté par un graphe, les machines par des noeuds. 
Pour chaque machine, les données affichées sont la charge ainsi que le contenu de la file d'attente.


\subsubsection{Actualisation de la vue}

\paragraph{} L'état du réseau doit-être visible en temps réel.

\paragraph{} La vue peut donc être actualisée toutes les $0.5$ secondes. 
Un délai plus faible risquerai de la rendre invisible (données clignotantes sur l'écran).


\subsection{Maintenabilité du code}

\paragraph{} Nous ne pensons pas que le projet sera totalement terminé le 8 Avril 2015, date de rendu du code et du mémoire.
Pour cela, nous avons défini quelques normes pour que le projet puisse être repris. (a détailler)

\paragraph{}



\newpage
\section{Répartitions des tâches}

\subsection{Diagramme de Gantt}

\rotatebox{270}{
\begin{ganttchart}[
hgrid,
vgrid,
inline = true,
x unit=4.5mm,
time slot format=isodate,
milestone inline label node/.append style={left=3mm}
]{2015-02-16}{2015-04-08}
\gantttitlecalendar{month=name, week, day} \\

\ganttgroup{Gestion du réseau (A)}{2015-02-16}{2015-03-01} \\
\ganttbar{A1}{2015-02-16}{2015-02-22} \\


\ganttmilestone{Livrable final}{2015-04-08}

\end{ganttchart}
}



\newpage

\subsection{Affectation des tâches}

\paragraph{}
\begin{tabular}{| l | M{5cm} | M{3cm} | M{5.5cm} |}
    \hline
    Fct & Description & Développeur(s) & Commentaire \tabularnewline
    \hline
    A1 & Création d'un noeud & Guillaume & blabla  \tabularnewline
    \hline
    A2 & Création d'un noeud & Guillaume \and Kévin & blabla  \tabularnewline
    \hline
    A3 & Création d'un noeud & Mounir \and Corentin \and Kévin & blabla  \tabularnewline
    \hline
    A4 & Création d'un noeud & Corentin \and Guillaume & blabla  \tabularnewline
    \hline
 \end{tabular}
 


\newpage

\section{Livrables}

\include{user_scenario}

\bibliography{identifications_besoins}

\end{document}