\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[tikz]{bclogo}
\usepackage{geometry}
\usepackage{array}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{pgfgantt}
\usepackage{url}
\bibliographystyle{alpha}
\usepackage[counterclockwise]{rotating}
\geometry{hmargin=2.5cm,vmargin=1.5cm}

\setlength{\parskip}{1ex plus 2ex minus 1ex}
\newcolumntype{M}[1]{
    >{\raggedright}m{#1}
}

\title{
 \begin{minipage}\linewidth
        \centering
        Simulation d'algorithmes d'équilibrage de charge dans un environnement distribué 
        \vskip3pt
        \large Architecture
    \end{minipage}
 }
 
\bibliographystyle{alpha}
\author{Kevin Barreau \and Guillaume Marques \and Corentin Salingue}

\begin{document}

\maketitle

\newpage

\renewcommand{\contentsname}{Sommaire} 
\tableofcontents

\newpage

\section{Architecture de Cassandra}

\paragraph{} Cassandra est une base de données distribuées, écrite en langage Java. Dans sa version 2.1.2, elle est composée de 963 fichiers, répartis dans 62 dossiers, pour un total de 126 502 lignes de codes et 36 287 lignes de commentaires.

\paragraph{} Cassandra est un projet riche et complet. Nous ne nous intéresserons qu'aux parties de son architecture sur lesquelles nous allons travailler.

\paragraph{} Par ailleurs, nous ne nous intéresserons pas non plus à la représentation sous forme de diagramme de classes de Cassandra, étant donné une forte utilisation du pattern \textit{singleton} et des méthodes \textit{statiques}. Cette représentation donne peu d'information sur le fonctionnement de la base de données.

\subsection{Staged event-driven architecture (SEDA)}

\paragraph{} Cassandra est basée sur une architecture de type Staged Event Driven Architecture (SEDA). Cela permet de séparer des tâches dans différents emplacements, appelés \textit{stages}, qui sont connectés par un service de messages. Chaque stage possède une file d'attente pour les messages (un message correspondant à une tâche à traiter), ainsi qu'un ensemble de threads pour traiter les tâches (voir figure \ref{fig:stages}).

\paragraph{} Dans le cas de Cassandra, la gestion des stages se fait dans le package \path{org.apache.cassandra.concurrent}. Les stages sont -pour la plupart- énumérés dans \textit{Stage}. Ils sont ensuite gérés par le \textit{StageManager} (qui a pour particularité de ne posséder que des méthodes et des attributs statiques). Nous nous intéresserons principalement aux stages :

\begin{itemize}
	\item \textbf{READ} : lectures locales
	\item \textbf{GOSSIP} : communications sur l'état des noeuds
\end{itemize}
\paragraph{} Ces stages permettent de répondre à différents besoins.

\paragraph{} Le stage "READ" permet de répondre aux besoins des protocoles d'affectation. L'idée est de créer un nouveau stage "QUEUE\_MANAGER" pour gérer les file d'attentes du stage de lecture. Ainsi, les tâches traitées par le stage "READ" entraîneraient un message vers le stage "QUEUE\_MANAGER", envoyant un message pour supprimer un message d'une file d'attente dans les autres noeuds ayant à traiter la même tâche. Les noeuds recevant le message le transmettraient au stage "QUEUE\_MANAGER" qui s'occuperait alors de supprimer le message voulu de la file d'attente s'il y est encore présent. La figure \ref{fig:read_request} montre un exemple avec une requête de lecture arrivant sur le noeud 5, et avec les données à lire sur les noeuds 1 et 2.

\paragraph{} Le stage "GOSSIP" permet de répondre aux besoins qui concernent la communication des données locales d'un noeud. Les noeuds de la base de données s'échangent des informations sur leur état toutes les secondes. L'ajout de données locales entraînera la modification du stage "GOSSIP" pour permettre l'envoi de ces nouvelles données.

\subsection{Gossip}

\paragraph{} Cassandra utilise le protocole Gossip pour les communications entres les noeuds. Chaque noeud envoie les informations qu'il possède -sur lui et sur les autres noeuds- à au plus 3 autres noeuds du réseau. Cela permet d'avoir pour chaque noeud une connaissance globale du réseau avec un minimum d'interaction.
\paragraph{} Les classes en rapport avec Gossip se situe dans package \path{org.apache.cassandra.gms}. La classe chargée de traiter les tâches de Gossip est \path{org.apache.cassandra.gms.Gossiper}.
\paragraph{} Gossiper maintient une liste de noeuds "vivants" et "morts" (des noeuds inatteignables). Toutes les secondes, le module démarre un tour. Un tour entier de Gossip est composé de trois messages. Un noeud X envoie un message syn à un noeud Y pour initialiser Gossip. Y, à la réception de ce message syn, renvoie un message ack à X. Pour répondre à ce message ack, X envoie un message ack2 à Y pour compléter le tour (voir la figure \ref{fig:round_gossip}).

\subsection{Modèle de données}

\paragraph{} Le modèle de données de Cassandra s’appuie sur un schéma dynamique, avec un modèle de données orienté colonne (voir figure \ref{fig:keyspace}). On retrouve les classes gérant la modélisation de la base de données au sein du package \path{org.apache.cassandra.db}.

\begin{itemize}
	\item \textbf{Keyspace} : le conteneur des données de l'application
	\item \textbf{Row} : une ligne dans le Keyspace, composée d'une clé et d'un ensemble de colonnes
	\item \textbf{DecoratedKey} : un token identifiant le positionnement d'une ligne dans la base de données
	\item \textbf{ColumnFamily} : un ensemble de colonnes pour une ligne donnée
	\item \textbf{Column} : un tuple contenant un nom, une valeur et un \textit{timestamp} (la date de la mise à jour la plus récente de cette colonne)
\end{itemize}

Nous allons nous intéresser dans notre projet à la classe \textbf{ColumnFamily}, afin de pouvoir garder une trace de la popularité des objets. Les objets étant définis par un token, porté par la classe \textbf{DecoratedKey}, ColumnFamily est l'objet dont nous souhaitons connaître la popularité.

\subsection{Statistiques}

\paragraph{} Cassandra possède un système permettant d'exposer des mesures internes, grâce à la libraire \textbf{Metrics} [\textit{https://github.com/dropwizard/metrics} (à mettre en bibliographie)].

\paragraph{} Les classes s'occupant de collecter les mesures se situent dans le package \path{org.apache.cassandra.metrics}. Chaque classe de Metrics est chargé de collecter des statistiques sur certaines classes de Cassandra, comme par exemple sur la classe Keyspace vue précédemment dont les données sont collectées par \path{org.apache.cassandra.metrics.KeyspaceMetrics}.

\paragraph{} L'intêret dans le cas de notre projet est de pouvoir exposer les mesures initiales de Cassandra, mais aussi d'ajouter des mesures sur les implémentations que nous allons faire. Il nous sera possible d'ajouter une nouvelle classe de Metrics pour répondre à ce besoin.

\paragraph{} Une classe de Metrics est liée à une classe que l'on souhaite de manière bidirectionnelle. C'est à dire que la classe que l'on souhaite observée possède en attribut une instance de la classe de Metrics, à laquelle elle passe en paramètre sa propre référence. La référence n'est pas stockée par la classe de Metrics mais seulement utilisée dans des \textit{closures}.

\newpage

\begin{figure}[p]
	\centering
		\include{schemas/stages}
	\caption{Schéma de deux stages dans une architecture SEDA \label{fig:stages}}
\end{figure}

\begin{figure}[p]
	\centering
		\include{schemas/read_request}
	\caption{Exemple simplifié d'une requête de lecture au niveau des stages, avec l'ajout d'un stage "QUEUE\_MANAGER" \label{fig:read_request}}
\end{figure}

\begin{figure}[p]
	\centering
		\include{schemas/round_gossip}
	\caption{Tour de messages Gossip entre les noeuds X et Y \label{fig:round_gossip}}
\end{figure}

\begin{figure}[p]
	\centering
		\include{schemas/keyspace}
	\caption{Modèle de données de Cassandra \label{fig:keyspace}}
\end{figure}

\end{document}